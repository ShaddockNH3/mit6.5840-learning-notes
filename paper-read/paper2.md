# paper 2 实用的容错虚拟机系统设计

## 摘要

简单来说，就是如何用最便宜的硬件、最少的性能损耗，通过记录并重放每一个操作，来实现一个永远不会宕机的系统。

## 引言

怎么复制省力，在哪里复制最方便？

总的来说，这里介绍了一下笨方法和聪明方法。

笨的方法就是每次进行一个动作，就把这个动作记录下来，然后传给备份机，等备份机确认收到后，再进行下一个动作。

但是记录状态数据量很大，而且网络传输也有延迟。

所以聪明的方法是只传输指令，而不是状态数据本身。

初始状态一样，听到的指令一样，顺序一样，结果就一样。

然而，物理机会有非确定性操作，例如有些操作依赖于时间。

真实的硬件很难控制这些细微的差别，所以这里使用虚拟机来屏蔽这些差别。

当主虚拟机执行一个非确定性操作时，它会把这个操作的结果记录下来，并传给备份虚拟机，备份虚拟机就可以使用相同的结果来保持同步。

这就是确定性重放。

这样的设计不需要昂贵的机器，而且传输的数据很少。

但是只支持单处理器虚拟机，不支持多核处理器。

## 基本设计

主虚拟机负责接收所有的东西，备份虚拟机负责做一模一样的事情。

但是备份虚拟机不能输出任何的东西，因为这样会导致重复输出。Hypervisor 会丢掉备份虚拟机的输出。

他们也是共享一个磁盘的，也就是共享日记本。

虽然看到的数据是一样的，但是遵循主机写，备份机的操作也是被丢掉，避免重复写入。

### 2.1 确定性重放实现

初始状态一样 + 输入一样

非确定性动作包括可以有中断，读取时间，以及未定义的副作用（例如一些 CPU 指令）

所以这个是时候可以使用日志通道，也就是主虚拟机把精力的所有事情都打包给日志，然后通过网络传给备份虚拟机。

当主虚拟机执行第 N 个操作被中断了，这件事也会被记录，这个时候备份虚拟机也必须在执行完第 N 个操作后被中断。

过去为了省力会攒一波中断等到一个时间点一起发送。

VMware 的做法利用 CPU 硬件性能计数器秒回。

### 2.2 FT 协议

如果主虚拟机挂了，备份虚拟机怎么才能装做什么都没发生过。

主要是三个部分。

#### 输出要求

如果 Primary 刚刚给客户发送了一条消息，你的存款余额是 100 元，然后挂了。

Backup 必须也认为余额是 100。

所以输出要求就是：

当 Backup 接管的时候，它的状态必须能推导出与 Primary 已经发送给外界的所有输出完全一致的结果。

#### 输出规则

在 Backup 确认之前，Primary 不能发送任何输出。

当 Primary 想要向外部（例如网络）发送数据。

Primary 不能直接发送出去，必须先把这个数据的操作日志发给 Backup。

Primary 吧数据缓存，然后等待 Backup 回复收到日志。

只有收到了 Backup 的确认，Primary 才能把数据发送出去。

如果 Primary 在等待 Backup 确认之前就把数据发给客户，然后瞬间挂了。这个时候 Backup 还没收到日志，它根本不知道刚才发生过这个操作。Backup 上线后，就会丢失这段历史，导致和客户看到的世界不一致。

#### Non-blocking

之前的旧系统每次要发输出的时候，Primary 必须完全停止工作，等 Backup 回复后才能继续。

而 VMware 的做法是只延迟发送，但是继续执行其他操作。

在等待 Backup 确认的时候，CPU 是不休息的，继续跑下一行代码，只是那个要发出去的网络包被暂时扣留。

### 相应与检测故障

在容错系统里，如何保证对方没有挂掉？

主要是两种方法。

#### 心跳

服务器之间通过 UDP 协议不停的发送心跳信号，如果心跳停止了，说明对方可能出事了。

#### 呼吸

正常地操作系统总是有定时器终端，所以主备之间的日志通道里，数据流应该像呼吸一样连绵不断。

如果日志流突然彻底停滞，那就说明对方哪怕没死，也已经失去意识，进入假死状态。

#### 应对策略

一旦确认对方 挂了，活着的那一方就宣布进入 Go Live，也就是独立运行状态，不再需要同步。

#### 备份机上位

如果 Primary 挂了，Backup 并不是一瞬间变成 Primary。

1. 消化存货：Backup 可能囤积了几条刚刚收到，还没执行的日志
2. 追赶进度：Backup 必须先把这些剩下的日志全部重放玩，直到追上 Primary 挂掉时的状态
3. 正式上线：Backup 宣布自己是新的 Primary
4. 广播天下：新的 Primary 会在网络上广播自己的 Mac 地址

#### 脑裂

假设 Primary 和 Backup 都活的很好，但是网络断了，会导致双方都认为对方挂了，要独立运行。

然后他们就会往同一个共享磁盘里写数据，会造成数据损坏。

因此，使用存放虚拟磁盘的共享存储设备来仲裁。

当任何一方宣布自己要 Go Live，必须先去共享存储上的一个特定位置执行一个原子操作。

成功者设置标志位，系统允许其变成 Primary，失败者主动停止运行。

如果虚拟机连共享存储都连不上了，那就干脆直接等待，无影响。

#### 自动恢复

当原来的 Backup 变成了新的单点 Primary 后，系统自动在集群里找一个新的 Backup 来和它配对。

## FT 的实际实现

### FT VMotion

#### 传统方法

想要复制一个正在运行的虚拟机，通常得把它暂停下来，复制数据，然后再恢复运行。

传统的 VMotion 方法是把虚拟机从服务器 A 迁移到 服务器 B。

而 FT VMotion 则是复制，它把服务器 A 上的虚拟机原封不动地克隆一份到服务器 B 上，原来的那个不晓辉，变成了 Primary，新的那个变成了 Backup。

#### 如何发生

1. 准备：系统在后台悄悄复制内存状态
2. 暂停：在最后的一瞬间，系统会让主虚拟机暂停一下，通常这个时间不到一秒
3. 握手：在暂停的一瞬间，Primary 和 Backup 建立起日志通道，并且确认谁是 Primary，谁是 Backup
4. 启动：Primary 进入记录模式，Backup 进入重放模式
5. 恢复：暂停结束，完全感受不到刚刚发生了什么

#### 集群服务

分身放在哪？不可能和真身放在同一台服务器上。

使用集群服务。

- 选址：当我们要启动 FT 时，或者旧的 Backup 挂了需要一个新的时，Primary 会向集群请求。
- 评估：找一台资源最空闲且能访问共享存储的服务器
- 安置：调用 FT VMotion，在那台最佳服务器上把 Backup 建立起来。

即便是 Backup 挂了，几分钟内就可以在别的地方生出一个新的 Backup，冗余就建立起来了

### 管理日志通道

#### 传递信息机制

首先是主备之间的传递信息机制。

大水桶：Primary 和 Backup 每个人手里都又一个日志缓冲区

传递过程：

1. Primary 一边干活，一边把生产出来的日志往自己的日志缓冲区里倒
2. 水桶里的日志会顺着日志通道/网络流进 Backup 的日志缓冲区里
3. Backup 从自己的日志缓冲区里拿出日志，一点一点重放
4. Backup 每消耗一点日志，就会向 Primary 汇报 ACK

#### 堵车

如果两个人消化日志的速度不宜一样怎么办？

有两种情况。

如果是 Backup 太快了，那么 Backup 只能停下来等 Primary 生产更多日志，这个是没问题的。

如果是 Primary 太快了，Backup 处理的太慢，这个时候 Primary 必须强制停下来等 Backup 追上来。

#### 为什么不能让 Backup 掉队

如果 Primary 挂了，Backup 必须把所有日志重放完才能变成新的 Primary。

如果 Backup 落后了 10 秒，那么等它接管的时候就有 10 s 的服务中断。

我们的希望是瞬间完成，最好小于 100 ms。

#### 限速令

如果 Backup 真的太慢了，那就只能让 Primary 慢一些。

也就是慢速反馈循环。

1. 监控：系统时刻盯着两者的差距，如果 Backup 落后超过 1 s
2. 限速：系统就会告诉 CPU 调度器，给 Primary 的 CPU 时间稍微减少一点点
3. 动态挑正：
    - 如果 Backup 还是跟不上，就再把 Primary 限速一点点
    - 如果 Backup 追上了，就加快 Primary 的速度

### 虚拟机操作

主要讲的是控制权和搬家的问题。

虽然 Primary 和 Backup 像影子一样同步，但是如果要让他们迁移，应该听谁的呢？

#### 控制权

一切的操作，例如关机、重启、调整资源都必须先在 Primary 上发生。

Primary 收到命令后，会生成一条特殊的控制条目，通过日志通道传给 Backup。

Backup 收到之后就会照做。

#### 在线迁移

唯一允许 Primary 和 Backup 之间独立进行的操作时 VMotion，也就是在线迁移，把虚拟机从一台服务器搬到另一台服务器。

虽然可以随便搬，但是不可以把 Primary 和 Backup 搬到同一台服务器上。

#### Backup 如何迁移

当虚拟机要迁移的时候，在切换最后的瞬间，必须保证所有的磁盘读写都静止。

对于 Primary 来说，它要静止很简单，只要等它干完手头的活就行了。

而对于 Backup 来说，它是一个模仿者，正在重放 Primary 的动作。

如果 Primary 一直不停地写数据，那么 Backup 就必须不停地写数据。

Backup 没法决定自己要停下来搬家，因为它必须时刻保持和 Primary 同步。

解决的方法是 Primary 帮 Backup 暂停。

1. 当 Backup 准备后最后一步搬家时，会给 Primary 发送一个信号
2. Primary收到这个信号后 ，会暂时静默自己的磁盘 IO
3. 这个静默动作会记录成日志，传给 Backup
4. Backup 重放这条日志时，自然也完成了静默 磁盘 IO
5. 静默的一瞬间，Backup 瞬间完成搬家切换
6. 完成后，Primary 继续跑，Backup 继续追

### 磁盘 IO 如何实现

在虚拟机的世界里，CPU 比较听话，但是磁盘 IO 很麻烦，因为它是通过 DMA，也就是直接内存访问，绕过 CPU 去直接读内存的。

这造成了 3 个问题

1. 如果同时去读数据
    - 磁盘的操作是非阻塞的，意味着这可以同时发生。
    - 如果同一时间有两个磁盘操作都想去改写同一个磁盘位置，或者同一个内存页面，不知道谁先谁后，这种顺序的非确定性会导致主备虚拟机状态不一样
    - 解决方法是不允许并行，必须串行，强制它们在主备虚拟机上都以相同的顺序串行执行
2. 读数据的时候，其他人要写
    - 会产生竞争，如果主备发生这种竞争的时间点稍微不一样，读出来的数据就不一样了
    - 解决方案（被否决）可以是给内存加锁，但是性能开销很大，会让电脑变慢
    - 最终的解决方案是反弹缓冲区，写入磁盘时先把数据复制到反弹缓冲区，再从这里写入磁盘，读取磁盘时先把数据 督导反弹缓冲区，等读完了，再把数据复制给虚拟机。这样虚拟机的程序就永远不会在磁盘 IO 上冲突了
3. Primary 倒下前的最后一刻 IO
    - 当 Primary 挂了，Backup 接管的时候，Backup 日志里写 Primary 刚刚发起了一次磁盘写入请求
    - 但是 Backup 根本不知道 Primary 的这个请求有没有成功
    - Backup 自己是不能发 IO 的，所以它也没有完成信号
    - 后果就是一直等下去，最后崩溃
    - 解决方法就是既然不知道，那等 Backup 上位后再次重新发出这些未完成的 IO 即可

## 设计代替方案

此前都是在讲默认配置。

### 共享磁盘 vs 非共享磁盘

之前是共享磁盘的设计，也就是 Primary 和 Backup 连接到同一个物理存储，系统把这个共享硬盘视为外部设备。

只有 Primary 能写，且 Primary 在写之前必须等 Backup 确认。

如果主备设备隔得很远，那么 Primary 和 Backup 分别有自己的本地硬盘。

系统把硬盘视为内部状态。

现在 Backup 也要写，并且，这里 Primary 在写硬盘的时候，不需要遵守严格的输出规则去推迟写入，因为这是写给自己看的，只要日志传过去了，Backup 迟早也会写到自己的硬盘上，不会影响外部一致性。

因为距离的问题，例如 Primary 在美国，Backup 在欧洲，共享存储线太贵也太慢了。

非共享模式允许通过普通的网络连接实现长距离容错。

但是代价是启动慢，因为 Primary 得把整个硬盘内容完整的复制给 Backup，而不是只复制内存。

重启也很慢且脑裂风险大，因为没有共享存储了。

解决方法是只能找一个第三者来做仲裁，或者使用多数派算法投票。

### 省带宽

当虚拟机疯狂读硬盘，大量的数据涌入网络，带宽很容易被吃光。

所以能让备份虚拟机自己去读硬盘，别让主虚拟机通过通过网络把数据传过来。

传统的设置是 Primary 把自己看到的东西传过去，而这个方法是发指令让 Backup 自己去读。

但是这个方法有三个问题。

1. Backup 读的和 Primary 读的速度不一样，例如 Backup 硬盘相应慢，重放速度也很慢
2. 读错。读错有两种情况 ，第一种是 Primary 成功，Backup 失败，这样的话 Backup 重读即可；第二种是 Primary 失败，这个时候 Backup 绝对不能自己都。当 Primary 失败的时候，必须把那个失败的结果通过日志传给 Backup，也就是即便 Primary 读出来是乱码，也得保证 Backup 得到的也是乱码
3. 读完就改。Primary 读完，紧接着几微妙后又写入。而 Backup 是有延迟的，读出来的新数据。解决方法是推迟写入，必须等 Backup 发完读好旧数据后才能写新数据。

开了这个，坏处是实际吞吐下降 1 % - 4 %，好处是日志带宽大大降低

## 评估

对于绝大多数企业级应用（数据库、计算），FT 的损耗微乎其微（<10%），完全可以商用。

普通的 1Gb 网络就足够支撑日志同步了，甚至可以支持异地容错。

如果是那种纯粹拼命跑网络吞吐的任务，FT 会因为日志同步和输出延迟稍微慢下来，但在 10Gb 网络下依然表现优异。

## 6 杂鱼前辈 (Mesugaki Version)

### Bressoud & Schneider 胆小如鼠的杂鱼

> 哈？Bressoud & Schneider 这种老古董，居然因为自己处理不好异步事件，就强行搞了个什么“纪元 (Epochs)”来拖慢节奏？真是笑死人了！而且每次要发个数据包，居然还要把整个主虚拟机完全停下来（Stop execution）等着？你是没长腿还是脑子转不动呀？看看人家 VMware FT，一边跑一边同步，丝般顺滑～像这种走一步停三步的笨重杂鱼，还是早点进博物馆养老吧！嘻嘻♪

### Java VM 这种偏科的弱鸡杂鱼

> 哎哟，Napper 还有 Friedman 那些人，折腾了半天只敢躲在 Java 虚拟机那个小圈子里玩过家家？一遇到多线程就吓得要到处加锁，稍微复杂一点的程序就处理不了。不像本小姐，无论是 Windows 还是 Linux，任何操作系统都能完美驾驭！这种全能的含金量，只能在特定环境里生存的杂鱼大叔你这辈子都理解不了吧？噗噗！

### Remus 只会用蛮力的笨蛋杂鱼

> 居然有人觉得“疯狂拍照 (Checkpointing)”就是高可用？Remus 那个笨蛋，每秒钟传几十次内存快照，把网线都撑爆了呢！居然能让性能下降 100% 到 200%？哈？你是来搞笑的吗？把电脑卡成 PPT 还有脸说自己是容错系统？睁大眼睛看看 VMware FT，用“确定性重放”这种天才般的脑子，只要传一点点日志（不到 20M 带宽）就搞定了。用脑子而不是用蛮力，这就是天才和杂鱼之间不可逾越的鸿沟哦～♡

### VMware FT 才是支配一切的神

> 听好了，真正的强者（VMware FT）是不需要像 Remus 那样浪费带宽，也不需要像 Bressoud 那样暂停系统的！我们用极其优雅的“确定性重放”，把性能损耗控制在 10% 以内，甚至还能隔着几十公里做容错。这种既省流又高效、还能自动处理故障的完美系统……杂鱼大叔你就只能跪在地上流着口水仰望了哦！想学会？下辈子吧！略略略～♪

## 后续工作

虽然很好，但是只支持单核处理器
