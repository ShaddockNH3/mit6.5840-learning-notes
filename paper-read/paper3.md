# paper 3 寻找一种易于理解的共识算法（扩展版）

## 摘要与引言

简单来说，Raft 是一种用于管理复制日志的共同算法。

过去，Paxos 算法太复杂了，Raft 旨在易于理解，并且达到相同的效果。

Raft 的核心概念是分解，把过程拆分为三个步骤。

1. 领导者选举。也就是选择一个领导，此后都听他的
2. 日志复制。领导决定复制什么，负责把所有消息告诉其他人，并且确保每个人都记到本子上
3. 安全性。制定一些不能打破的规矩，确保不管发生了什么故障，记录都不会混乱

Raft 和其他算法不同的地方主要有三点。

1. 强领导者。在 Raft 里，数据流向是单向的，所有的日志条目只能在从 Leader 流向 Follower。Leader 永远是对的，不需要向任何人拉取数据
2. 随机计时器选举。当需要重新选举 Leader 的时候，如果所有的竞争者同时要求选举，那么会产生冲突。Raft 让每台服务器在发起选举前，先随机睡一会儿，因为大家醒来的时间都不一样，所以先行来哪个就可以迅速当选
3. 联合共识。为了解决成员变更问题，当需要增加或者减少服务器的时候，Raft 创建了一种中间态，这种状态下必须获得“旧配置的大多数”以及“新配置的大多数”的同意，才能完成变更。这保证了在换届期间绝对不会出现两个 Leader，即使是在脑裂的情况下也可以保证数据安全。

## 复制状态机

简单讲起来就是一堆初态一致的服务器，它们都执行同样的命令序列，从而保证最终状态一致。

为了做到这一点，需要复制日志，日志的顺序得是一样的。

最后讲了一下什么样的系统是靠谱的，包括安全性、可用性（大多数节点都活着，系统就可以工作）、不依赖时序（不靠几点来决定事情，是靠逻辑）、高性能（大多数节点跑得快就可以，不需要等待已经死掉的节点）

## Paxos 的问题

Paxos 的问题主要就是太复杂了，难以理解和实现。从微观到宏观的拼凑。

## 为可理解性而设计

Raft 的设计目标是易于理解。为此有几个理念。

1. 问题分解。把问题拆分开来，每个部分单独只负责这一块问题
2. 简化状态空间。日志必须是连续的，Follower 的日志要么和 Leader 完全一样，要么比 Leader 短一点，不允许出现中间态
3. 随机化。在领导选举随机。

## Raft 算法

### Raft 基础

Raft 的世界里有三种角色：Leader、Follower、Candidate。

Follower 只听别人，Candidate 在 Leader 超时的时候发起选举，Leader 负责处理所有的请求。

大家刚启动的时候都是 Follower，如果 Follower 超时没有收到 Leader 的消息，就会变成 Candidate，发起选举。赢了变成 Leader，输了继续当 Follower。如果 Leader 发现有更高任期的消息，就会变成 Follower。

任期。在分布式系统里，物理时间是靠不住的，所以 Raft 使用了自己的时间——任期。

Term。

Term 可以理解为朝代，例如，秦朝、汉朝、唐朝。

每个钗黛开始之前都需要选举，任期号单调递增，只能向前，不能倒退。不管你是谁，只要看到别人的任期号比你大，你就得更新自己的任期号，并且退位为 Follower。

Raft 的沟通只靠两个 RPC。

第一个是 RequestVote RPC，由 Candidate 发起并广播给所有人，请求投票。每个人在一个任期内只能投一票，且只能投给日志最新的 Candidate。

第二个是 AppendEntries RPC，由 Leader 发起并广播给所有人，用于复制日志和发送心跳（带内容或者为空）。如果 Follower 收到的 AppendEntries 里包含了比自己日志更新的内容，就会把自己的日志更新到和 Leader 一样。

最后是数据结构。

Persistent 的部分是要存到硬盘，存三个东西。

1. currentTerm。当前任期号
2. votedFor。当前任期投给谁了
3. log[]。所有命令的历史记录

Volatile 的部分是内存里的，重启就没了。

1. commitIndex。已经提交的最高日志索引
2. lastApplied。已经应用到状态机的最高日志索引

安全性。

这里只要记结论就好了。

1. 选举安全性：每个任期最多只能选出一个 Leader
2. 领导者之追加：Leader 只能 append，不能改写
3. 日志匹配：如果在第五行写了吃饭，那么 1-4 行写的东西一定是一模一样的
4. 领导者完整性：新 Leader 必须拥有老 Leader 已经确认提交过的所有重要文件

### 领导者选举

这里其实就是 Leader 选举的细节。

#### 触发机制

每个服务器都有一个倒计时器。

Follower：只要 Leader 还在，就会不停的发送心跳。每次收到心跳，Follower 就会把计时器重置，如果 Leader 挂了，计时器到期，就会变成 Candidate。

#### 竞选流程

当 Follower 变成 Candidate 的时候，它会做三件事。

1. 任期号加一
2. 给自己投票
3. 给所有人发送 RequestVote RPC

#### 结果

总共会有三个情况。

1. 赢了。收到大多数人的投票，变成 Leader，开始发送心跳
2. 输了。收到别人的心跳，而且对方的任期号更高或者一样大，变成 Follower
3. 平局。票分散，也没有收到心跳，继续发起新一轮选举

#### 随机化

如果大家的超时时间都一样，那么每次都会平局。Raft 让每个服务器随机选择一个时间，推荐是 150 ms 到 300 ms，这样就能避免平局。

#### 为何要随机

本来想搞一个排名系统，但是太复杂了，所以就干脆直接随机。

### 日志复制

这里是日志复制的细节。

#### 领导者职责

一旦 Leader 当选成功，它的工作就开始了。

1. 接单。Client 把命令发给 Leader
2. 记账。Leader 把命令记到日志里
3. 传单。Leader 把命令发给所有 Follower
4. 确认。Leader 等待大多数 Follower 确认，然后把命令提交
5. 执行。Leader 去真正修改内存里的内容，然后告诉 client
6. 通知。Leader 在下一次心跳里顺便告诉所有 Follower 刚刚那条命令已经提交了，让它们也去执行

#### 安全性

只要满足两个条件，所有人的日志都不会乱。

1. 索引 + 任期 = 身份证。每条日志都有自己的索引和任期号，两个加起来就能唯一标识一条日志。例如 A 的日志里的第 5 行写的是 `Term 3, x = 5`，B 的日志里的第 5 行写的是 `Term 5, ...`。那么就不需要看内容，就可以保证两条命令一定是一样的
2. 连坐。如果你的第 5 行和我一样，那么第 1 - 4 行也一定一样

如何保证生效？

Leader 发送新命令的时候会附带上一条的索引和任期号，Follower 会检查自己的第 5 条，如果一样就接受，不一样就拒绝。

#### 处理不一致

如果 Follower 的日志和 Leader 的不一致，Leader 会不断地往前找，直到找到一个匹配的点，然后从那个点开始复制。

强制覆盖。

#### 优化

如果 Follower 落后太多，一次次 -1 太慢了。Follower 可以在拒绝的时候多发一句从哪里到哪里不一致，这样 Leader 就可以直接跳过去。不过这样有点过度优化，因为很少有服务器会落后那么多。

### 证明安全性

这里是安全性的细节。

#### 资格

Raft 里除了谁票多谁当选之外，还有一条：只有日志最新的 Candidate 才能当选。

解决方法很简单，在拉票的时候，Follower 会检查 Candidate 的日志。

- 比任期。谁的最后一条日志的任期号大，谁就更新
- 比长度。如果任期号一样，谁的日志更长，谁就更新

如果候选人比 Follower 还旧，Follower 就拒绝投票。

#### 当前任期做数

Leader 正在复制 前朝（Term 2）的日志，虽然已经被复制到了大部分（S1，S2，S3）手里，这个时候 S1 挂了，但是 S5 还可以当选（因为 S5 的 Term3 要比 S2、S3 的 Term2 新）

S5 当选之后，根本不知道 Term2 的日志已经被复制到了大部分手里，所以 S5 可能会覆盖掉 Term2 的日志。

所以，Leader 不允许直接提交前朝的日志，Leader 必须等自己的任期内产生了一条新的日志，并且这条日志被大多数确认后，才能确认前朝的日志已经被提交了。

#### 如何证明

证明过程就不细看了。

### 跟随者和候选人崩溃

如果 Follower 崩溃了，Leader 继续工作就好了，一直发。

等 Follower 重启了，它会从 Leader 那里补齐日志。

注意幂等性，避免重复写。也就是如果刚写完日志 5 就挂了，重启之后又收到了日志 5，就不能再写一次，直接回复成功就好了

### 时序和可用性

Raft 的安全性不依赖于时间，但是可用性依赖于时间。

也就是：

广播时间 << 选举超时时间 << 平均故障间隔时间

简单来说，广播时间必须得快很多，如果广播时间太慢，那么就会频繁触发选举，系统就不稳定了。选举超时时间通常设置为 10ms 到 500ms之间，必须足够长，并且容忍偶尔的网络抖动。平均故障间隔时间，现实机器一般几个月乃至几年才坏一次。

## 集群成员变更

Raft 设置的是联合共识方案。

### 为什么不能直接换

想把 3 台服务器扩展成 5 台，如果 Leader 只是简单的发送通知，因为网络是有延迟的，所以有的服务器收到了，有的没收到。

这个收会产生脑裂，即服务器 A 认为集群是 3 台，只要 $ [3/2]+1=2 $ 票就可以当选 Leader，服务器 B 认为集群是 5 台，也就是 $ [5/2]+1=3 $ 票才能当选 Leader。

此时就产生了两个 Leader。

### 两阶段过渡

为了避免上述所说的，Raft 规定不可以直接跳过去，这个时候需要经过一个中间态，也就是联合共识。

需要老配置和新配置都同意，才能完成变更。

主要有四个阶段。

1. 开始。Leader 收到扩容请求
2. 进入联合共识。Leader 创建并广播一个包含老配置和新配置的联合配置日志条目
3. 当老配置和新配置都提交之后，Leader 再广播最新的新配置日志条目
4. 完成。当新配置提交之后，集群就完成变更

### 三个问题

1. 新来的服务器日志是空的，追数据需要好久。解决方法是新来的不要投票，只复制。
2. Leader 要把自己移出集群。解决方法是 Leader 做好最后一班，再 C_new 提交之前，还是 Leader，发现不在名单里，就退位为 Follower。
3. 被移除的服务器收不到心跳，以为 Leader 挂了，发起选举。现任 Leader 看到比自己大的 Term 又会退位为 Follower，然后陷入循环。解决方法是无视被移除的服务器的选举请求。

## 日志压缩

由于日志会越来越大，所以需要剪裁。否则，存储和传输的开销都会变得很大。

Raft 直接用一个最简单的方法，就是快照。类似存档，存了当前的档之后，前面的就可以删掉了。

### 存档

Leader 不会给所有人存档，每台服务器，包括 Leader 和 Follower 都会负责自己的存档和日志剪裁。

当日志大小超过一个阈值，例如 64 MB 的时候，服务器就会开始存档。

存什么？

1. 状态机数据：当前的 x = 5 等结果
2. 元数据：为了接上新日志必须要流的东西：
    - lastIncludedIndex。存档里最后一条日志的索引
    - lastIncludedTerm。存档里最后一条日志的任期号
    - 最新的集群配置

存好之后，把前面的删掉就好了。

### 掉队

如果 Follower 掉队太远，连 Leader 还没删的日志都没有怎么办。

举个例子，就是 Leader 已经存好档，把 1-100 的日志都删掉了，只留了 100 往后的，这个时候来了一个 Follower，它是空的。

Leader 想发给它 101、102、103…… 可是 Follower 连 100 都没有，没法接。

所以这个时候 Leader 直接采用 installSnapshot RPC，把存档直接发给 Follower，让它直接装上。

简单来说就是 Leader 把大文件切成小块发过去，然后 Follower 把自己的旧日志清空到被覆盖的部分，直接变成快照里的状态。

为什么不让 Leader 统一发快照，因为这样节省了网络带宽，实现起来也简单。

### 技巧

- 快照频率。不能太频繁也不能太少。当日志大小达到上次快照大小的某个倍数（例如 2 倍）的时候，触发一次，这样开销是均摊的
- 写时复制。防止存档的时候系统卡顿。建议利用操作系统的方法 Fork。

## 客户端交互

这里主要解决两个问题。

1. 如何防止重复下单
2. 怎么读到最新的数据

### 如何找到 Leader

客户端先随便找一个发送请求，如果是 Leader 直接处理，如果是 Follower 那就拒绝然后告诉客户端谁是 Leader，客户端再去找 Leader。如果客户端挂了，那就随便找一个重新开始。

### 防止重复下单

序列号去重。

每个客户端都有一个唯一的 ID，客户端的每个命令都有一个递增的序列号，状态机里会记录每个客户端最近执行过的序列号。这样实现了线性化语义，无论重试多少次，系统里都只执行了一次。

### 只读请求

只读理论上直接读内存，不需要写日志，但是会产生脑裂，也就是读旧数据的风险。

所以设置两个东西。

空日志。

当新的 Leader 当选后，不知道前朝哪些日志真好了，它必须先发一条空日志并提交。

确认。

当有人来查余额的时候，Leader 在回答之前得先发一轮心跳问一圈自己还是不是 Leader，等到大多数人都回复了，才说明自己真的是 Leader，可以放心回答。
