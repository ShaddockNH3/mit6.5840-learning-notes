# Lec 1: Introduction

## 课程核心

这门课的核心目的是解决利用多台计算机构建分布式系统时遇到的挑战：

1. **并行资源管理**
   如何高效地管理和调度多台机器的 CPU、内存等计算资源。

2. **容错 (Fault Tolerance)**
   冗余备份机制。两台计算机共同运行一个程序（或持有数据副本），一台出错宕机，另一台还能保证系统正确运行。

3. **通信模型**
   解决节点间网络通信的延迟、丢包和开销问题。

4. **隔离性与安全性 (Isolation/Security)**
   用户代码（如 Map/Reduce 函数）通常是不可信的，可能会出现预料之外的 Bug。系统设计必须确保单个任务的崩溃不会影响整个集群的稳定性。

5. **局部错误 (Partial Failure)**
   分布式系统特有的棘手问题。单机错误通常很彻底（如断电），容易排查；而多机环境下的“局部错误”难以捉摸——例如某台机器硬盘故障或网络抖动，但其他机器仍正常运行，导致系统处于一种“半死不活”的异常状态。

6. **性能扩展 (Scalability)**
   $ N $ 台计算机加在一起，能否提供 $ a \times N $ 的性能（$ a $ 为小于 1 的常数）？构建分布式系统的根本动力就是为了获取超越单机的更高性能。

## 课程 lab

1. MapReduce - 分布式计算框架
2. Raft - 通过复制来让系统容错的算法，管理复制
3. KV 服务器 - 用 Raft 建立一个可容错的 KV 服务器
4. 分片式 KV 服务 - 把 KV 分散到一系列的独立集群，并行加速

## 主线

主要讨论存储、通信、计算。不过更多的是讨论存储，并且设计一部分计算（MapReduce）。分布式系统最终的目标是抽象成一个对外暴露完全是一个非分布式操作系统，实际内部是分布式的一个系统。

考虑抽象的时候，需要考虑以下几个事情

1. 实现
    - 使用 RPC，RPC 的目标事实上就是掩盖不可靠网络通信的事实。
    - 线程，可以驾驭多核心计算机，提供结构化并发操作。
    - 并发控制需要锁。
2. 性能
    - 可扩展性。可扩展系统提升，堆计算机数量可以获得 $ n $ 倍性能/吞吐量，否则就需要付费让程序员去重构软件。
        - 一个简单的例子就是假设某天你的个人网站突然爆火，有 1 亿的流量需要登陆注册，最简单的方法肯定是买更多的 web 服务器去分流。但是你买了一定数量的服务器之后，每台服务器事实上都得和同一个数据库进行交互，这个时候 web 服务器和数据库通信又成了瓶颈，所以需要重构数据库，分成多个数据库后，后面就只要继续砸钱就可以扩展。
        - 而不是每次陷入性能瓶颈都要重构。
3. 容错
    - 单台计算机的罕见错误在服务器集群上变得常见甚至一直发生。例如程序运行错误，电源错误，网络不稳定（有人踩到电缆，网线掉了，风扇故障导致过热）以及更多神秘的错误（原文翻译如此），所以是不可靠的。
    - 可用性。在某种特定类型的错误下（如果超出范围的错误那没办法），系统可以正常运行，可以提供给你完整的服务，就像他们没有发生任何错误。也就是建立冗余服务，例如有两个备份，一个错了另一个还能跑。
    - 可恢复性。如果出现问题，有人来修之后，系统可以继续正常运行。建立在没有损失正确性的前提下，在系统崩溃前做一些事情。太多错误积累系统自动停止工作，直到被修复，然后也可以依旧正确工作。
    - 非易失性存储。设检查点。
    - 复制。非易失性存储又贵又慢。复制主要碰到的问题是处理同步问题。（lab2）
4. 一致性
    - 假设一个分布式系统只会两种操作，Put 和 Get。在非分布式系统中，这很容易。但是在分布式系统中，因为会有副本、缓存等的存在，所以这两个简单的操作都很麻烦。放入得放入多份，更新也得更新多份。
    - 强一致性。必须保证每个副本都是最新的。最简单的方法就是读每一个副本然后比较。很昂贵。
        - 那如果把副本的物理位置都放在一起呢，这样不就可以避免远距离对比吗？
        - 某天有人绊倒了机房的线，所有副本都没了。
        - 所以需要把每个副本放在足够远的地方。
    - 弱一致性。可以允许一定量的副本不是最新的。

## MapReduce

先看论文。
