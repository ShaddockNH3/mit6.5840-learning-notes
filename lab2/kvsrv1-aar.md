# kvsrv1-aar

很神秘，莫名其妙（并非莫名其妙）突然过了。

现在想来应该是因为在任务一的时候就基本考虑了网络不可靠的情况，所以最后只加了一个 time.Sleep() 就过了。

回头想想，任务一之所以 race 没过，很大概率就是因为考虑了网络不可靠的情况，导致处理时间超时。

所以这里就直接把任务一、三、四的思路放一起讲，把任务二单独拿出来讲。

其实这次的 lab 是不难的，官方给的文档内容非常详细了。

## 任务一

首先拿到题目之后，依旧是要看 lab 的框架。首先是看 kvsrv1 目录下的 rpc 了解定义的数据结构，然后就直接去看 client.go 和 server.go，知道大概要干嘛。

本次任务其实就是让你写一个 k-v 存储，事实上就是类似 map 那样，可以存储键值对，并且可以通过键去获取值。

所以其实就显而易见了，首先处理 Get 请求，Get 请求就是通过 key 去获取 value。

写一个 for 循环，在发送请求后，根据错误处理，如果 ok 都是 false 了，那就重发一次；如果不是空键且不是 ok，那就说明是其他神秘的错误，所以也重发一次；如果 ok 是 true，那就说明成功获取到了值，直接返回，其他情况直接 break 即可。

然后是 Put 请求，Put 请求就是通过 key 去设置 value。

和处理 Get 请求类似的，如果 ok 是 false，那就重发一次；如果是版本错误并且是第一次发送，那说明肯定是版本错误，直接返回版本错误；如果是版本错误但不是第一次发送，那么返回可能错误；如果是 ok，那就返回 ok，其他情况直接 break 即可。

接下来是 server，其实这个时候才想着要定义 KVServer 的数据结构。思考了一下，事实上就是一个 map，所以直接定义一个 map[string]string 即可。但是要存储版本号，本来是想着专门定义一个 struct 来存储 value 和 version 的，但是后来想想其实没必要，直接定义两个 map 即可，一个存储 key-value，另一个存储 key-version。

然后就是写 server 的 Get 和 Put。

Get 其实很简单，就是根据 key 去获取 value 和 version，然后根据请求的内容返回相应的结果。

对于 Put，首先根据 key 去获取当前的内容，首先是判断版本号，如果是版本错误，那么就返回版本错误；如果不是版本错误，那么就更新 value 和 version，然后返回 ok 即可。

如果是第一次发送的请求，也就是没找到 key 对应的内容，那么直接新建一个 key-value 和 key-version 即可。

在写完之后，给 Client 的 Put 和 Get 加上锁，防止并发问题。

然后开始跑测试，发现 -race 没过，仔细思考之下，实在没有结论，于是先写任务二。

## 任务二

任务二一上来也是先看 lock 目录，知道要干啥。

思考之下，事实上就是给 kvsrv1 加一个锁的功能。根据参数 l 作为锁的 key，然后通过 kvsrv1 的 Put 和 Get 来实现锁的获取和释放。

最开始还没有理解这一层，所以进行了一些尝试。

比如说，直接在 Lock 里定义了一个 currentlockName，然后写了写发现不妥，后面修改为 lastlockName。

之前的思路是这么想的，就是通过 Get 去获取上一个任务到底好没好，然后来决定下一个任务能不能获取锁。

然后发现根本没必要，只需要定义这把锁到底是 locked 还是 unlocked 即可。

所以整体的逻辑就是，Acquire 的时候，先通过 Get 去获取锁的状态，如果不 ok 且键为空，那么继续请求。如果 value 为 unlocked，那么就通过 Put 去把锁设置为 locked，然后返回成功。

对于 Release 想法类似，先 Get，如果不 ok 那么继续获取，如果成功那么就判断 value 是不是 locked，然后放进去 unlocked 即可。

对于上面的逻辑，其实是有点问题的。首先是关于 Release 的问题，其实都执行到 release 了，那么就说明锁是被持有的，所以其实不需要判断 value 是不是 locked，直接放入 unlocked 即可。

第二是关于初始化的问题。当时的初始化是直接在磁盘里初始化锁的状态为 unlocked，但是 Acquire 获取的时候，因为 Key 实际上并不存在，所以 Server 应该是直接返回 Value = "" 的。我的逻辑是 if value == "unlocked" 才能申请获取这把锁。如果是第一次获取锁，那么 value 肯定是 ""，所以就会一直重试下去，导致死锁。

仔细想一下，直接把空字符串当作 unlocked 即可，这样解决了所有的问题。

## 任务三、四

昨晚处理了任务一和二之后就去睡觉了，起来之后继续看任务三，结果发现原来我问题 1 就处理了问题三和问题四要求的东西，所以只加了一个 time.Sleep() 就过了。

后来仔细想想，我任务一过不了 race 的原因很大概率是考虑了 3 和 4 的错误处理。

## 后续

这次任务其实有点莫名其妙的过了，感觉还需要再找个时间复盘一下。

其中一个原因可能是因为我用的是 2020 版的课和 2025 版本的网站，导致课的内容和网站的内容有点出入，一下没看懂要做什么。

还有一个原因感觉像是题目的注释给的提示其实太完善了，导致其实并不需要太多思考就能完成任务。
