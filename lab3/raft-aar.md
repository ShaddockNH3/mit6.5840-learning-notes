# raft

Raft 有四个任务，一个个写好了，写完一个就写一个的笔记。

## 任务 1

第一个部分的任务按道理就是保证领导能够一直保持下去。这部分的内容初上手很抽象，第一部分后半部分的完成靠了一部分的 AI 辅助。其实感觉还是论文没读透。昨天把任务 1 搓出来了之后，现在趁着复盘再研究一下整体的逻辑，并且再看一遍论文。

感觉还是大局观有点差，没把整体的逻辑捋清楚就开始搓了，所以导致搓出来一直是有问题的。

第一步就是根据论文里的图 2 规划数据结构，首先就是实现 Raft 的数据结构，这里没什么好说的，跟着论文里些就好了。需要注意的是得额外给 log 一个数据结构，因为 log 在原文里的定义是 Term 和 Command 接口。

除了原文里有的，还需要有一些额外的东西，身份、上次收到心跳的时间以及选举超时时间。这里最开始习惯性的用的是 Timer，但是题目说直接使用 time 然后套一个 for 循环即可，所以就不用了。

关于 lastHeartbeat 和 electionTimeout，这里需要说一下。

应该是得专门有一个函数去更新 lastHeartbeat 和 electionTimeout。但是一开始的时候没有注意 electionTimeout，而且 lastHeartbeat 也写的会有问题。

其实是因为最开始的时候完全没有理解清楚为什么要这两个东西，后来想明白了。

lastHeartbeat 是用来判断 Leader 是不是活着的，electionTimeout 是用来判断是不是应该启动选举。

由于每个人的选举超时时间是不一样的，所以 electionTimeout 需要在每次收到心跳包的时候重新生成一个随机的时间。但是总体这个时间一定是比心跳间隔要长的。

所以，应该是每个人在初始化的时候，lastHeartbeat 一定是得到的 time.Now()，而 electionTimeout 则是随机分配的超时时间。

一旦这个 lastHeartbeat 和现在的时间减一下，超过选举时间，那么肯定是超时。

electionTimeout 最开始设置的是 500 ms，后来想想应该确实是随机的，不然每个人都同时发送选举。

而代码框架里那个 50 ~ 350 ms 的是 Leader 的心跳包发送间隔，electionTimeout 只要比这个长即可，我设置的是 400 ~ 700 ms。

接下来是 GetState 函数，这个函数其实不难，就是锁一下，然后返回当前朝代和现在是不是领导即可。

紧接着就是写 RequestVote RPC，首先根据论文里去定义数据结构，也就是 Args 和 Reply。

然后正式开始写 RequestVote 函数。

这里先填一个我在最后才注意到的逻辑，也就是：

如果 RPC 请求或响应中包含的任期号 T > currentTerm，那么设置 currentTerm  = T，并转换为 Follower。

这个逻辑，所有的 RPC 请求应该都得在最开始有。

所以，加完锁之后。

首先应该先判断 args.Term 和 currentTerm 的大小关系。

如果 args.Term > currentTerm，那么就把 currentTerm 设置成 args.Term，然后把身份改成 Follower，votedFor 设置成 -1，-1 代表的是 nil。

之后再根据 RequestVote 的逻辑去写。

也就是论文里说的——

如果 term < currentTerm，返回 false。

如果 votedFor 为空或者等于 candidateId，并且候选人的日志至少和接收者一样新，则投赞成票。

第一个分支很好写，只要当 term < currentTerm 的时候，直接返回 false 即可。

第二个分支就复杂一些了。

第二个分支的前半段不难，就是判断 votedFor 是不是 -1 或者等于 args.CandidateId。

后半分支得额外掏出来写，当日志长度为 0 或者候选人的朝代大于等于当前的朝代，设置 uptoDate 为 true。

后面就是如果两个条件都满足，那么就把 votedFor 设置成 args.CandidateId，然后返回 true，还得 resetTimer 一下，否则就是 false。

接下来就是 ticker 的逻辑，之前我一直把 ticker 的逻辑写的很乱，现在仔细想想，不应该写的那么乱。

ticker 有三种情况，如果是 Leader，那就向每个人发送心跳包，如果不是 Leader 且超时，那么就触发选举逻辑。

如果都不是，那就啥也不干，安安稳稳的即可。

注意，ticker 是发送的逻辑，而不是接受的逻辑，所以不应该往里面放任何接受的部分。我之前就搞混了，一直想放接受的逻辑。

现在如果一个人要发送选举，那么应当重置自己的时间，然后写一个 for 循环给每个人发。当然如果是自己就跳过。

这里我忘了可以用 go func() 直接去处理，而是一直在那里想怎么 go 一个别人已经写好的函数，忘了可以自己去写。

逻辑其实就是送，如果不是选举态或者不是当前自己的朝代（这个时候朝代已经 + 1 了），那么就还没进入选举态，直接返回。

然后是经典 RPC 判断，一旦别人的朝代有比我更大的，那么就重置，然后 return。

如果选举成功了，那么票数 + 1，然后如果超过半数，那么就当选，当选后可以直接发一次心跳包广播。

然后讲一下发心跳包的逻辑，其实逻辑是类似的，写一个 for 循环，也是并发 go 发送。

接下来是 AppendEntries RPC，这里代码里本来是没有的，是要照着论文去写。

所以照着论文写了一下 Args，Reply 以及 sendAppendEntries 还有 AppendEntries。

这个函数的逻辑是接收。

只要接收了，那么重置时间即可，当然再次之前得去判断两个东西，一个是经典大家都要遵守的东西，还有一个是它要的逻辑，就是接收朝代小于传进来的朝代，那么就返回接受失败即可。

Make 的逻辑没什么好说的。

反正总的来说我是觉得目前的逻辑很乱，我还得再次看一遍论文，先优化一遍 3 A 的逻辑，然后再开始 3 B。

## 任务 1 - 逻辑优化

再看了一遍论文，复盘了一下，任务 1 应该是要求写论文里要点 5.1 - 5.2 的内容。

其实就是把 go func() 那个东西搞明白就可以了，其他属于细节性的东西。

## 任务 2

raft 的第二个任务是日志复制。

写起来确实满头大汗，碰到各种很神秘的问题。

首先其实和任务 1 一样，在一开始写的时候并没有很完整的去看完它的逻辑。题目让我们写 Start，然后就去写了 Start。

然后本来是打算把所有论文里要求的逻辑都放在 Start 里，但是后来发现这样会很乱，而且是完全错误的。

这里我是用的我笔记里记的东西：

1. 接单。Client 把命令发给 Leader
2. 记账。Leader 把命令记到日志里
3. 传单。Leader 把命令发给所有 Follower
4. 确认。Leader 等待大多数 Follower 确认，然后把命令提交
5. 执行。Leader 去真正修改内存里的内容，然后告诉 client
6. 通知。Leader 在下一次心跳里顺便告诉所有 Follower 刚刚那条命令已经提交了，让它们也去执行

Start 应该起的只是接单的作用，所以只需要把命令发给 Leader，然后 Leader 把命令放到自己的日志里，剩下的东西应该放在 ticker 处理。

这里应该需要理解一下所有的参数分别是什么。

index 是该命令如果被提交将出现的索引，term 是该命令被接收时的领导朝代，isLeader 是当前节点是不是领导。

然后接下来没有急着去改 Start，而是先去写 AppendEntries 的逻辑。

这部分的逻辑只需要照着论文里写就好了，也就是：

1. 如果 $ \text{term} < \text{currentTerm} $，返回 false （参考 §5.1）。
2. 如果日志中不包含在 prevLogIndex 处任期号匹配 prevLogTerm 的条目，返回 false （参考 §5.3）。
3. 如果现有的条目与新条目冲突（索引相同但任期号不同），删除现有的该条目及其之后的所有条目 （参考 §5.3）。
4. 追加任何在日志中尚不存在的新条目。
5. 如果 leaderCommit $ > $ commitIndex，将 commitIndex 设置为 $ \min(\text{leaderCommit}, \text{新条目最后一条的索引}) $。

这里需要注意的感觉应该是 resetTimer 的位置。

应该是放在第二个步骤之后，因为只要是收到了 AppendEntries，那么就说明 Leader 是活着的。

Success 放在最后即可。

写到这里其实陷入了僵局，因为我不知道要干啥了，所以就开始改 ticker 的逻辑，企图在 broadcastHeartbeats 里传参，告诉它这是心跳包还是日志复制，还是通知。

但是后来发现这样就完全违背了 Raft 的初衷，肯定不能这么干。

Raft 的逻辑是根据 commitIndex 和 lastApplied 来判断哪些日志已经被提交了，哪些日志还没有提交。

所以要干嘛其实就很明朗了。

我在任务一里写的处理逻辑是如果成功和失败都什么都不做，这里需要按照步骤做事情。

这里首先先回顾一下 Raft 里的四个非易失性存储，任务 2 基本上都是和这个东西打交道。

而我在最开始的时候并没有注意到。

所有服务器上的易失性状态如下：

1. commitIndex：已知已提交的最高日志条目的索引（初始化为 0，单调递增）
2. lastApplied：已经被应用到状态机的最高日志条目的索引（初始化为 0，单调递增）

Leader 上的易失性状态（选举后需要重新初始化）：

1. nextIndex[]：对于每一个 Follower，Leader 下一个将要发送给它的日志条目的索引（初始化为 Leader 最新日志索引 ( +1 )）
2. matchIndex[]：对于每一个 Follower，已知已复制到该服务器上的最高日志条目的索引（初始化为 0，单调递增）

所以在成功之后，随着心跳成功之后，应该是：

更新在这个 Follower 上，我们要发的下一条日志索引；

更新我们已经确认对方匹配到的索引。

也就是

```go
rf.nextIndex[server] = args.PrevLogIndex + len(args.Entries) + 1
rf.matchIndex[server] = rf.nextIndex[server] - 1
```

nextIndex 其实就是猜测对方下一个日志应该是什么。

matchIndex 就是对方已经匹配到的最高日志。

所以，nextIndex 应该变成刚刚发过去的数据包的最后一条日志的下一个索引，因为猜测对方已经匹配上了，所以 matchIndex 就是 nextIndex - 1。

然后下面的逻辑是看要不要提交。

发出去的日志可能一个人收到了，也有可能都收到了。

所以要找出那个最新的，已经被大多数人都存下来的日志索引，把它提交掉。

所以应该从 N 开始，也就是 rf.commitIndex + 1，然后往后找。

然后遍历每一个 peers，如果 rf.matchIndex[i] >= N 的话，那么就说明这个人已经匹配到了 N，那么票数就 +1。

当然因为选举的问题，还得判断朝代，必须朝代一样才能提交。

如果超过半数，那么就把 commitIndex 设置成 N。

如果失败了，那么就回退 nextIndex 1 步（暂时的处理），因为这一步说明对方的日志不匹配，那么就往前退一步，看看能不能匹配上。

写到这里，突然意识到我是不是从来没发过消息。

想了一下，根据论文里的逻辑，在 raft 的 struct 里加了一个 chan，也就是 applyCh。

然后后面就写不下去了，问了一下 AI，AI 给了我一个思路，说是额外写一个心跳包 applier 去处理，然后类似 ticke 那样不停检查是不是有新的日志需要提交。

所以我就写了一个 applier 函数，然后在 Make 里 go 起来。

applier 函数的逻辑应该是如果 commitIndex > lastApplied 的话，那么就说明有新的日志需要提交。

如果有的话，就把 lastApplied + 1，然后把日志发到 applyCh 里。

写完所有的逻辑之后，跑起来发现会有问题。

有两个问题，第一个问题是因为发的时候没上锁，所以会有竞态。

第二个问题是在网络跑起来的时候，也是上了锁的，所以跑的会非常慢。

两个问题可以弄成一个来解决，也就是总体采用三明治方法，先锁，然后深拷贝出来，然后解锁，然后发到网络进行处理，然后再锁，改状态，解锁。

无论是 applier 还是 ticker 里发消息都是这样。

所以把 applier 改为了加锁深拷贝解锁然后发到网络。

ticker 里的两个函数 broadcastHeartbeats 和 sendAppendEntries 改成了三明治方法。

至此，任务 2 的逻辑就完成了。

后续就是处理一下细节性的问题，比如说哪些东西需要作为变量拿出来加锁。核心逻辑写完之后后续其实都是在处理细节性的问题。

细节性的问题很严重，导致 raft 老是出问题。

后续就是不断的思考，然后把问题解决掉。

运行倒是没怎么运行过，主要大部分时间都在对着代码硬想怎么写。

## 任务 3

任务 3 是持久化和多步回退。

持久化非常好写，就是把 raft 里需要持久化的东西都存下来，然后每次启动的时候读出来。

根据示例代码写一下，然后在每个存储的地方调用一下就好了。

最开始的时候看论文还以为只需要在 RPC 最开始调用一下，但是细想之下不是。

然后尝试了一下 go test -run 3C，过了大部分测试，剩下的测试应该是多步回退的问题。

现在开始写多步回退。

论文原文如下：

如果需要，可以对协议进行优化以减少被拒绝的 AppendEntries RPC 的数量。例如，当拒绝一个 AppendEntries 请求时，跟随者可以包含冲突条目的任期以及它存储的该任期的第一个索引。有了这些信息，领导者可以递减 `nextIndex` 以绕过该任期内的所有冲突条目；这样，每个有冲突条目的任期只需要一个 AppendEntries RPC，而不是每个条目一个 RPC。在实践中，我们怀疑这种优化是否必要，因为故障很少发生，而且不太可能有很多不一致的条目。

根据论文里的描述以及官方给的提示，在 AppendEntriesReply 里加上三个东西：

* XTerm: 冲突条目的任期（如果有）
* XIndex: 该任期的第一个条目的索引（如果有）
* XLen: 日志长度

然后去修改 broadcastHeartbeats 里的逻辑。

也就是之前那个 else 分支，原本的逻辑是 nextIndex - 1，现在改成根据三种情况去处理。

情况 3 是 Follower 的日志太短，所以直接 nextIndex = XLen 即可。

情况 2 是 Leader 有 XTerm，那么 nextIndex = (Leader 对 XTerm 的最后一个条目的索引) + 1，循环查找 Leader 的日志，找到最后一个 XTerm 的索引，然后 +1 即可。

如果情况 1，就是 Leader 没有 XTerm，那么 nextIndex = XIndex 即可。

写完之后，应该是去改 AppendEntries 里的逻辑，也就是如果日志中不包含在 prevLogIndex 处任期号匹配 prevLogTerm 的条目，返回 false (参考 §5.3)。

这个得依据三种情况去返回就行。

跑了一下，过了所有测试。

## 任务 4

任务 4 是日志压缩，也就是快照。

首先应该是实现 Snapshot 函数，这个函数是修减日志并且更新状态的。

接下来就是修改 raft 的 struct，为每一个 raft 节点添加 lastIncludedIndex 和 lastIncludedTerm。

然后因为有这两个的存在，所以要去修改每一个用到 log[] 和 Term 的地方，都应该考虑快照的影响。

所以写了两个辅助函数，然后替换了所有用到 log[] 和 Term 的地方。

接下去就是考虑如何发送快照，想了一下，发快照应该是和发日志是类似的，但是他们之间应该是处于二选一的关系，所以在 broadcastHeartbeats 里改了一下逻辑，先判断是不是需要发快照，如果需要发快照，那么就发快照，否则就发日志。

发快照只要在最后的时候更新一下 nextIndex 和 matchIndex 即可，回顾一下，这两个分别是猜测对方下一个日志应该是什么，以及对方已经匹配到的最高日志。

这个时候引申出来下一个问题，事实上这个东西也是一个 RPC，所以得去写 InstallSnapshot RPC。

先写一个 sendInstallSnapshot 函数，然后写 InstallSnapshot 函数。

这个函数首先需要遵守 RPC 的通用规则，然后接下来是快照的逻辑。

快照先看有没有安装过，如果安装过了就返回。

如果没有安装过，那么就把快照存下来，然后更新自己的状态机。

然后持久化存储，存储完之后搬到 applyCh 里去执行。

写完之后跑了一下，发现有严重的并发问题。

看了一下，是因为锁的问题，修了锁的问题之后继续跑，结果还是有问题。

这次不是锁报错，是因为挂了之后重启，发现不对。

想了一下，应该是 Make 里没有考虑快照的问题。

所以在 Make 里加了一段逻辑，如果快照存在，那么就把快照读出来，然后开一个线程去更新状态机。

这样的话，挂了重启之后就能继续工作了。

重新跑了一遍，终于全过了。

## 小总结

怎么说呢，总体来说，Raft 的实现非常复杂，而且最后我的代码写出来一坨**大狗屎**，经常出现这里写了一个函数简单封装一下，然后那里就继续用原来了。

最后就索性基本没封装，除了那两个 3D 最后要求全改的东西。

然后还有一个问题就是其实很多时候写完了还是处于一个很懵逼的状态，自己都不知道自己为什么搓出来了。

感觉还是写出来了，还需要点时间去仔细复盘一下。

另外就是还是有点依赖于 AI 去提供思路了，很多时候都是自己走进死胡同里，然后问一下 AI，AI 给一个思路。

后面再去细看一遍论文，才发现其实很多东西论文里给的很清楚，只是自己没去细看。

总结一下有用到 AI 的地方，这些地方给的思路吧。

首先一个是并发的问题，一开始的时候并没有想到用 go func() 去处理并发问题，而是一直想着 go 已经写好的函数，忘了可以自己去写一个。

applier 也是类似的，最开始的时候没想到可以单独开一个线程去处理提交日志的问题，而是想着把提交日志的逻辑放在 ticker 里。

接下来是三明治方法，这个方法就是先锁，然后发送，最后再锁，放在网络里跑的时候不需要加锁。

然后是各种细节性问题，比如说漏改了一些地方的 log[] 和 Term，以及忘了考虑 Make 里重启的时候读快照。

实现完 InstallSnapshot 之后，习惯性的调用了普通的 persist()，但是事实上应该手动去存，不然读的都是旧的东西。

不过总的来说，AI 提供的还是辅助性的东西，核心逻辑还是得自己去想。

不然 AI 给的思路都不知道插在哪。

还有就是 AI 给的思路有时候也不对，得自己去判断。

还有一点，一开始的时候没有对要做的事情有宏观的概念以及整体规划，所以导致实现的时候有时候都不知道自己在干啥，debug 的时候也很迷茫。
