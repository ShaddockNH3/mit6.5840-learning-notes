# 康复训练

由于已经基本忘记了 go 的并行相关语法，这里重新回顾一下，并且回顾一下 go 的 test 语法。

Gemini 准备了 3 个小项目，待会儿也练习一下。

## 哈基米康复训练

### 🏥 康复训练一：并发计数器 (The Safe Counter)

**训练目标**：找回对 `goroutine`（并发执行）和 `sync.Mutex`（互斥锁）的感觉。
**核心逻辑**：1000 个人同时去抢 1 个苹果，怎么保证最后苹果真的被抢了 1000 次？

#### 1. 设计蓝图 (The Blueprint)

你需要定义一个**结构体 (Struct)**，把它想象成一个保险箱。

* **字段 A**：一个整数（比如 `count`），这是我们要保护的金币。
* **字段 B**：一把锁。

  * *复健提示*：去 `sync` 包里找 `Mutex`。它是把普普通通的锁。

#### 2. 动作分解 (The Steps)

1. **初始化**：造出这个保险箱实例。
2. **发动人海战术**：写一个循环（比如 1000 次）。
3. **启动分身**：在循环里，用 `go` 关键字启动一个匿名函数。

   * *关键点*：这个匿名函数就是你的“打工仔”。
4. **打工仔的任务**：

   * **第一步**：**上锁**。告诉所有人“我现在要操作了，你们别动”。

     * *API 提示*：`Lock()`
   * **第二步**：**干活**。把 `count` 加 1。
   * **第三步**：**解锁**。告诉所有人“我好了，下一个”。

     * *API 提示*：`Unlock()`
5. **主线程等待**：(这里先简单粗暴点) 让主线程睡个 1 秒钟，确保打工仔都跑完了。
6. **验收**：打印最后的 `count` 值。

#### ⚠️ 喵娘的警告 (The Trap)

* **坑点**：如果你忘了加锁，或者锁的位置不对。
* **检测手段**：不要只看结果对不对，要用**测谎仪**！

  * 在终端运行命令：`go run -race main.go`
  * 如果屏幕上没有出现红色的 `WARNING: DATA RACE`，那你才算通关！

---

### 🏥 康复训练二：RPC 乒乓 (RPC Ping-Pong)

**训练目标**：熟悉 `net/rpc` 标准库，这是 Lab 1 的生命线。
**核心逻辑**：在同一个程序里模拟“客户端”和“服务端”，通过网络协议传话，而不是直接调用函数。

#### 1. 协议定义 (The Protocol)

这是最重要的一步！

* **结构体 A (参数)**：客户端要传过去的数据（比如两个整数 `X`, `Y`）。
* **结构体 B (响应)**：服务端要传回来的数据（比如一个整数 `Result`）。
* **☠️ 致命死穴**：Go 的 RPC 库非常势利眼，**只有首字母大写的字段**它才肯传！

  * *错误示范*：`struct { x int }` -> 对方收到的是 0。
  * *正确示范*：`struct { X int }` -> 对方收到的是数据。

#### 2. 服务端逻辑 (The Server)

1. **定义对象**：写一个结构体（对象），给它绑定一个方法。

   * *方法签名限制*：Go RPC 要求方法必须长这样：
     `func (t *T) MethodName(argType T1, replyType *T2) error`
   * *逻辑*：把 `argType` 里的 X 和 Y 拿出来相乘，赋值给 `replyType` 指向的地方。
2. **注册开张**：

   * *API 提示*：`rpc.Register` (把你的对象注册上去)
   * *API 提示*：`rpc.HandleHTTP` (告诉系统我们要用 HTTP 协议)
3. **监听端口**：

   * *API 提示*：`net.Listen("tcp", ":1234")`
4. **开始服务**：

   * *API 提示*：`go http.Serve(...)` (记得在一个新的 goroutine 里跑，不然主线程就卡死在这了)

#### 3. 客户端逻辑 (The Client)

1. **拨打电话**：

   * *API 提示*：`rpc.DialHTTP` (连上 localhost:1234)
2. **准备数据**：实例化那个参数结构体，填入数据。
3. **远程调用**：

   * *API 提示*：`client.Call("结构体名.方法名", 参数, &响应容器)`
   * *注意*：第三个参数必须是**指针**（地址），因为你要让它把结果填进来。
4. **挂断**：检查有没有 `error`，打印结果。

---

### 🏥 康复训练三：优雅的等待 (Wait Group)

**训练目标**：学会 `sync.WaitGroup`。
**核心逻辑**：不再用 stupid 的 `time.Sleep(1秒)` 来等子线程，而是像幼儿园老师一样，点名确认所有小朋友都归队了再走。

#### 1. 工具准备

* 你需要一个 `sync.WaitGroup` 变量。

#### 2. 动作分解

1. **发号施令 (Add)**：

   * 在你**启动** goroutine **之前**（一定要在外面！），告诉计数器你要派几个人出去。
   * *API 提示*：`wg.Add(1)`
2. **派出任务**：启动 `go func() { ... }`。
3. **完成销账 (Done)**：

   * 在 goroutine 内部，任务做完的最后一行。
   * *推荐写法*：一进 goroutine 就写 `defer wg.Done()`，这样就算中间代码崩了，它也会记得去销账。
4. **死守关卡 (Wait)**：

   * 在主线程里，设一道卡。
   * *API 提示*：`wg.Wait()`
   * *效果*：程序会卡在这里不动，直到计数器归零。

#### 喵娘的警告 (The Trap)

* 如果你把 `Add(1)` 写在了 `go func` 的**里面**，会发生什么？

  * 有可能主线程跑到 `Wait()` 的时候，子线程还没来得及运行 `Add`，结果 `Wait` 看到是 0，直接退出了。**一定要在外面 Add！**
